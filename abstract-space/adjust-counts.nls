;; functions to ensure equal numbers of patches with each level of capacity...
;; this is a devious piece of code, which needs to be properly commented...

;; main adjustment function
to adjust-qs
  ;; target numbers of patches with each capacity level
  let target-counts count patches / levels
  ;; how far off each required count we currently are
  let adjust-counts map [ c -> int target-counts - count patches with [ capacity = c ] ] capacities
  set adjust-counts tweak-adjust-counts adjust-counts
  ;; random ordered list of the index values
  let my-range shuffle n-values levels [ i -> i ]
  foreach my-range [ c -> 
    let this-c item c capacities
    let y item c adjust-counts
    if y != 0
    [
      let short-list remove-item c adjust-counts
      let other-cs remove this-c capacities
      set short-list do-swaps y short-list this-c other-cs
      set adjust-counts insert-item c short-list 0
    ]
  ]
end

;; The adjustments are forced to sum to 0 (as they should)
to-report tweak-adjust-counts [ a ]
  let tweak sum a
  if tweak != 0
  [ ;; adjustment required
    let num-to-tweak abs tweak
    ;; get a random set of indexes for tweaking
    let item-indexes n-values num-to-tweak [i -> one-of capacities]
    ;; let item-indexes sublist (shuffle n-values length a [i -> i]) 0 num-to-tweak
    ;; the adjustment value required
    let adjust 0 - (num-to-tweak / tweak)
    foreach item-indexes [ i ->
      set a replace-item i a (item i a + adjust)
    ]
  ]
  report a
end


to-report do-swaps [ num-swaps swaps-to-do this-x other-x ]
  let over-represented? (num-swaps < 0)
  let proper-swaps []
  ifelse over-represented?
  [ set proper-swaps map [ swaps -> swaps > 0 ] swaps-to-do ]
  [ set proper-swaps map [ swaps -> swaps < 0 ] swaps-to-do ]
  let list-of-indexes []
  (foreach proper-swaps (n-values length proper-swaps [ i -> i ])
    [ [i j] ->
    if i [
      let idx j
      let num abs item idx swaps-to-do
      set list-of-indexes sentence list-of-indexes n-values num [ idx ]
    ]
  ])
  repeat (abs num-swaps) [
    let idx one-of list-of-indexes
    let x item idx swaps-to-do
    let that-x item idx other-x
    ifelse over-represented? [
      ask one-of patches with [ capacity = this-x and any? neighbors4 with [ capacity = that-x ] ] [
        set capacity that-x
      ]
      set swaps-to-do replace-item idx swaps-to-do (x - 1)
    ] 
    [
      ask one-of patches with [ capacity = that-x and any? neighbors4 with [ capacity = this-x ] ] [
        set capacity this-x
      ]
      set swaps-to-do replace-item idx swaps-to-do (x + 1)
    ]
  ]
  report swaps-to-do
end

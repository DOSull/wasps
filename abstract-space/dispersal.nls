;; The MIT License (MIT)
;;
;; Copyright (c) 2020 David O'Sullivan
;;
;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without restriction,
;; including without limitation the rights to use, copy, modify, merge,
;; publish, distribute, sublicense, and/or sell copies of the Software,
;; and to  permit persons to whom the Software is furnished to do so,
;; subject to the following conditions:
;;
;; The above copyright notice and this permission notice shall be included
;; in all copies or substantial portions of the Software.
;;
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.


;; PATCH function
;; distributes the next generation to new locations
;; (which might be this patch in many cases!)
to disperse [next-gen]
  ;; next generation is a set of 3 numbers [wild GM sterile]
  ;; which we iterate over incrementing the index position each time
  (foreach next-gen (n-values num-subpops [i -> i]) [ [new-cases idx] ->
    ;; previously this was an ifelse clause
    ;; IMPORTANT: that causes incorrect erasure of previously dispersed
    ;; new-cases from patches processed earlier in the loop
    if new-cases > 0 [
      ;; determine any long-distance dispersals and apply them
      let n-ldds binomial new-cases p-ldd
      repeat n-ldds [
        disperse-to one-of roads 1 idx
      ]
      ;; now do the locals remaining (this will be most of them)
      ifelse  use-kernel-method?
      [ disperse-using-kernel (new-cases - n-ldds) idx]
      [ disperse-using-heading-and-distance (new-cases - n-ldds) idx ]
    ]
    ;; DON'T reimplement this!
;    [ ;; if for some reason you do, then use the increment-list-item version
;      set next-pops increment-list-item next-pops idx 0
;      set next-pops replace-item idx next-pops 0
;    ]
  ])
end


;; PATCH function
;; convenience reporter for patch-at from a coordinate pair list
to-report my-patch-at [xy]
  report patch-at item 0 xy item 1 xy
end


;; PATCH function
;; uses a kernel which is list of lists
;; [[ offset-x offset-y ] weight ]
;; n is the number of individuals
;; idx is their type 0 = wild 1 = GM 2 = sterile
;;
;; this appears to run more slowly than the simple heading and distance
;; formula in spite of repeated efforts to speed it up
;; I think it's because often the kernel has several hundred bins
;; and so there is not much gained assigning cases to several hundred
;; bins versus a thousand or so random heading distance draws
;; Also problematic is that it is difficult to get the right mean distance
;; by manipulating the kernel weights
to disperse-using-kernel [n idx]
  if n > 0 [
    foreach rnd:weighted-n-of-list-with-repeats n my-kernel [p -> last p] [ t ->
      let xy item 0 t
      disperse-to my-patch-at xy 1 idx
    ]
  ]
end

;; PATCH function
;; simple dispersal by selection of random heading and distance
to disperse-using-heading-and-distance [n idx]
  repeat n [
    let target nobody
    while [target = nobody] [
      set target patch-at-heading-and-distance (random-float 360) (random-exponential d-mean)
    ]
    disperse-to target 1 idx
  ]
end


;; PATCH function
;; disperse to the specified target patch
;; the specified number of cases of the
;; specified type 0 = wild 1 = GM 2 = sterile
to disperse-to [tgt num idx-type]
  ask tgt [
    if capacity > 0 [
      increment-population idx-type num
    ]
  ]
end


;; this tries to report a list [[ dx dy ] n] but is very slow
;; not used
to-report get-dispersal-counts [n]
  let targets map [ x -> first x ] (rnd:weighted-n-of-list-with-repeats n my-kernel [p -> last p])
  let counts remove-duplicates targets
  report map [ tgt -> (list tgt count-x-in-list targets tgt) ] counts
end


to-report count-x-in-list [L x]
  report length filter [ y -> y = x ] L
end


;; setup dispersal kernels
to setup-kernel
  if debug? [ reset-timer ] 
  simulate-kernel
  reduce-kernel
  if debug? [ show (word "simulated kernel: " timer) ] 
  if debug? [ reset-timer ] 
  setup-patch-kernels
  if debug? [ show (word "set patch kernels: " timer) ] 
end


to simulate-kernel
  ask patches [ set freq 0 ]
  ask central-p [
    repeat 1000000 [
      let tgt patch-at-heading-and-distance random 360 random-exponential d-mean
      if tgt != nobody [
        ask tgt [
          set freq freq + 1
        ]
      ]
    ]
  ]
  set kernel-offsets [dxdy central-p self] of patches with [freq > 0]
  set kernel-offsets sort-by [ [a b] -> dist a < dist b ] kernel-offsets
  set kernel-weights map [ xy -> mean map [ptch -> [freq] of ptch] (patches-at eight-fold xy central-p) ] kernel-offsets
end


to-report dxdy [p1 p2]
  let xy1 get-coords p1
  let xy2 get-coords p2
  report (list (item 0 xy2 - item 0 xy1) (item 1 xy2 - item 1 xy1))
end


to reduce-kernel
  ;; normalise to sum to 1 and filter to keep only those with p > p-ldd
  let total-w sum kernel-weights
  set kernel-weights filter [ w -> w / total-w > p-ldd ] kernel-weights
  ;; apply corresponding filter to the offsets
  let kernel-size length kernel-weights
  set kernel-offsets sublist kernel-offsets 0 kernel-size
  ;; zip them together into a single list of two lists
  set kernel zip kernel-offsets kernel-weights
end


to setup-patch-kernels
  ;; make patch local copy masked to only include patches that exist in the world
  ask patches [
    set my-kernel filter [ xyp -> my-patch-at item 0 xyp != nobody ] kernel
;    set my-kernel map [ xyp -> mask-missing-patches xyp ] kernel
  ]
end

to-report mask-missing-patches [xyp]
  ifelse my-patch-at item 0 xyp = nobody 
  [ report replace-item 1 xyp 0 ]
  [ report xyp ]
end


to show-kernel
  let mx-f max [ln (freq + 1)] of patches
  ask patches [
    set pcolor scale-color cyan ln (freq + 1) mx-f 0
  ]
end


to-report get-kernel-mean-d
  report sum map [ xyw -> (mean-d-to-patch-at item 0 xyw) * (item 1 xyw) ] kernel / sum map [ xyw -> item 1 xyw ] kernel
end


to-report get-coords [p]
  report (list ([pxcor] of p) ([pycor] of p))
end


;; convenience distance reporter for coordinate pair
to-report dist [xy]
  report sqrt (item 0 xy ^ 2 + item 1 xy ^ 2)
end


;; utility function to zip two lists into a list of pairs
to-report zip [L1 L2]
  report (map [ [a b] -> (list a b) ] L1 L2)
end


;; transpose a list of lists
to-report transpose [LL]
  report map [ i -> map [ a -> item i a ] LL ] index-list LL
end


;; get a list of index positions for the supplied list
to-report index-list [L]
  report n-values length first L [i -> i]
end


to-report eight-fold [xy]
  let x item 0 xy
  let y item 1 xy
  report (list (list x y) (list (- x) y) (list x (- y)) (list (- x) (- y))
               (list y x) (list y (- x)) (list (- y) x) (list (- y) (- x)))
end


to-report patches-at [L p]
  report map [ xy -> [my-patch-at xy] of p ] L
end

;; The MIT License (MIT)
;;
;; Copyright (c) 2020 David O'Sullivan
;;
;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without restriction,
;; including without limitation the rights to use, copy, modify, merge,
;; publish, distribute, sublicense, and/or sell copies of the Software,
;; and to  permit persons to whom the Software is furnished to do so,
;; subject to the following conditions:
;;
;; The above copyright notice and this permission notice shall be included
;; in all copies or substantial portions of the Software.
;;
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

;; PATCH function
;; distributes the next generation to new locations
;; (which might be this patch in many cases!)
to disperse [next-gen]
  ;; next generation is a set of 3 numbers [wild GM sterile]
  ;; which we iterate over incrementing the index position each time
  (foreach next-gen (n-values num-subpops [i -> i]) [ [new-cases idx] ->
    ;; previously this was an ifelse clause
    ;; IMPORTANT: that causes incorrect erasure of previously dispersed
    ;; new-cases from patches processed earlier in the loop
    if new-cases > 0 [
      ;; determine any long-distance dispersals and apply them
      let n-ldds binomial new-cases p-ldd
      repeat n-ldds [
        disperse-to one-of roads 1 idx
      ]
      ;; now do the locals remaining (this will be most of them)
      ifelse  use-kernel-method?
      [ disperse-using-kernel (new-cases - n-ldds) idx]
      [ disperse-using-heading-and-distance (new-cases - n-ldds) idx ]
    ]
    ;; DON'T reimplement this!
;    [ ;; if for some reason you do, then use the increment-list-item version
;      set next-pops increment-list-item next-pops idx 0
;      set next-pops replace-item idx next-pops 0
;    ]
  ])
end

;; PATCH function
;; convenience reporter for patch-at from a coordinate pair list
to-report my-patch-at [xy]
  report patch-at item 0 xy item 1 xy
end

;; PATCH function
;; uses a kernel which is list of lists
;; [[ offset-x offset-y ] weight ]
;; n is the number of individuals
;; idx is their type 0 = wild 1 = GM 2 = sterile
;;
;; this appears to run more slowly than the simple heading and distance
;; formula in spite of repeated efforts to speed it up
;; I think it's because often the kernel has several hundred bins
;; and so there is not much gained assigning cases to several hundred
;; bins versus a thousand or so random heading distance draws
;; Also problematic is that it is difficult to get the right mean distance
;; by manipulating the kernel weights
to disperse-using-kernel [n idx]
  if n > 0 [
    foreach rnd:weighted-n-of-list-with-repeats n my-kernel [p -> last p] [ t ->
      let xy item 0 t
      disperse-to my-patch-at xy 1 idx
    ]
  ]
end

;; PATCH function
;; simple dispersal by selection of random heading and distance
to disperse-using-heading-and-distance [n idx]
  repeat n [
    let target nobody
    while [target = nobody] [
      set target patch-at-heading-and-distance (random-float 360) (random-exponential d-mean)
    ]
    disperse-to target 1 idx
  ]
end


;; PATCH function
;; disperse to the specified target patch
;; the specified number of cases of the
;; specified type 0 = wild 1 = GM 2 = sterile
to disperse-to [tgt num idx-type]
  ask tgt [
    if capacity > 0 [
      increment-population idx-type num
    ]
  ]
end


;; this tries to report a list [[ dx dy ] n] but is very slow
;; not used
to-report get-dispersal-counts [n]
  let targets map [ x -> first x ] (rnd:weighted-n-of-list-with-repeats n my-kernel [p -> last p])
  let counts remove-duplicates targets
  report map [ tgt -> (list tgt count-x-in-list targets tgt) ] counts
end

to-report count-x-in-list [L x]
  report length filter [ y -> y = x ] L
end


;; setup dispersal kernels
to setup-kernel
;  setup-kernel-lists
  simulate-kernel
  reduce-kernel
  setup-patch-kernels
end

;to setup-kernel-lists
;  ;; make a offset coordinate lists
;  let r ceiling (min (list world-width world-height) / 2)
;  let dxs n-values (2 * r + 1) [x -> x - r]
;  let dys n-values (2 * r + 1) [y -> y - r]
;
;  ;; make empty lists
;  set kernel-offsets []
;  set kernel-weights []
;
;  ;; create the kernel offsets list
;  foreach dxs [ x ->
;    foreach dys [ y ->
;      set kernel-offsets lput (list x y) kernel-offsets
;    ]
;  ]
;  ;; sort in order of distance from the origin
;  set kernel-offsets sort-by [ [xy1 xy2] -> dist xy1 < dist xy2 ] kernel-offsets
;  if debug? [
;    show dxs
;    show dys
;    show sublist kernel-offsets 0 10
;  ]
;end

to simulate-kernel
  ask patches [ set freq 0 ]
  ask central-p [
    repeat 1000000 [
      let tgt patch-at-heading-and-distance random 360 random-exponential d-mean
      if tgt != nobody [
        ask tgt [
          set freq freq + 1
        ]
      ]
    ]
  ]
  set kernel-offsets [dxdy central-p self] of patches with [freq > 0]
  set kernel-offsets sort-by [ [a b] -> dist a < dist b ] kernel-offsets
  set kernel-weights map [ xy -> mean map [ptch -> [freq] of ptch] (patches-at eight-fold xy central-p) ] kernel-offsets
end


to-report dxdy [p1 p2]
  let xy1 get-coords p1
  let xy2 get-coords p2
  report (list (item 0 xy2 - item 0 xy1) (item 1 xy2 - item 1 xy1))
end


to reduce-kernel
  ;; assign the relative weights
  ;; this doesn't seem to get the weights right essentially
  ;; because the mean distance to origin of a unit square is not
  ;; the distance at the centre
  ;set kernel-weights map [ xy -> 1 / d-mean / exp (dist xy / d-mean) ] kernel-offsets
  ;; normalise to sum to 1 and filter to keep only those with p > p-ldd
  let total-w sum kernel-weights
  set kernel-weights filter [ w -> w / total-w > p-ldd ] kernel-weights
  ;; apply corresponding filter to the offsets
  let kernel-size length kernel-weights
  set kernel-offsets sublist kernel-offsets 0 kernel-size
  set kernel zip kernel-offsets kernel-weights
end

to setup-patch-kernels
  ;; make patch local copy masked to only include patches that exist in the world
  ask patches [
    set my-kernel filter [ xyp -> my-patch-at item 0 xyp != nobody ] kernel
  ]
end

to show-kernel
  let mx-f max [ln (freq + 1)] of patches
  ask patches [
    set pcolor scale-color cyan ln (freq + 1) mx-f 0
  ]
end

to-report get-kernel-mean-d
  report sum map [ xyw -> dist item 0 xyw * item 1 xyw ] kernel / sum map [ xyw -> item 1 xyw ] kernel
end

to-report get-coords [p]
  report (list ([pxcor] of p) ([pycor] of p))
end

;; convenience distance reporter for coordinate pair
to-report dist [xy]
  report sqrt (item 0 xy ^ 2 + item 1 xy ^ 2)
end

;; utility function to zip two lists into a list of pairs
to-report zip [L1 L2]
  report (map [ [a b] -> (list a b) ] L1 L2)
end

;; transpose a list of lists
to-report transpose [LL]
  report map [ i -> map [ a -> item i a ] LL ] index-list LL
end

;; get a list of index positions for the supplied list
to-report index-list [L]
  report n-values length first L [i -> i]
end

to-report eight-fold [xy]
  let x item 0 xy
  let y item 1 xy
  report (list (list x y) (list (- x) y) (list x (- y)) (list (- x) (- y))
               (list y x) (list y (- x)) (list (- y) x) (list (- y) (- x)))
end

to-report patches-at [L p]
  report map [ xy -> [my-patch-at xy] of p ] L
end

to-report mean-d-in-patch-at [a b]
  ifelse a = 0 and b = 0
  [ report 4 * mean-d-in-subpatch-at 0.000001 0.000001 0.5 ]
  [ report mean-d-in-subpatch-at (a - 0.5) (b - 0.5) 1 ] 
end

to-report mean-d-in-subpatch-at [x0 y0 a]
  let axy1 sqrt (a ^ 2 + 2 * a * x0 + x0 ^ 2 + y0 ^ 2)
  let axy2 sqrt (2 * a ^ 2 + x0 ^ 2 + y0 ^ 2 + 2 * a * (x0 + y0))
  let axy3 sqrt (a ^ 2 + x0 ^ 2 + 2 * a * y0 + y0 ^ 2)
  let r00 dist (list x0 y0)
  
  report (   
      8 * x0 * y0 * (r00 - axy1 + axy2 - axy3)
    - 8 * a * y0 * (axy1 - axy2) 
    - 8 * a * x0 * (axy3 - axy2) 
    + 8 * a ^ 2 * axy2 
    +   (x0 ^ 3 + 3 * a * x0 ^ 2 + 3 * a ^ 2 * x0 + a ^ 3) * (ln (axy2 - a - y0) - ln (axy1 - y0))
    + 4 * (a ^ 3 + 3 * a ^ 2 * y0 + 3 * a * y0 ^ 2 + y0 ^ 3) * (ln (a + x0 + axy2) - ln (x0 + axy3))
    + 5 * (a ^ 3 + 3 * a ^ 2 * x0 + 3 * a * x0 ^ 2 + x0 ^ 3) * (ln (a + y0 + axy2) - ln (y0 + axy1))
    + 2 * x0 ^ 3 * asinh (y0 / x0) 
    - 2 * x0 ^ 3 * asinh ((a + y0) / x0)
    + 2 * x0 ^ 3 * ln (r00 - y0)
    + 4 * x0 ^ 3 * ln (y0 + r00) 
    + 4 * y0 ^ 3 * ln (x0 + r00) 
    - 2 * x0 ^ 3 * ln (axy3 - a - y0) 
    - 4 * x0 ^ 3 * ln (a + y0 + axy3) 
    - 4 * y0 ^ 3 * ln (a + x0 + axy1) 
  ) / 24
end

to-report asinh [z]
  report ln (z + sqrt (1 + z ^ 2))
end

to-report distance-between-patches [p1 p2 style]
  let numbers get-required-numbers style
  let n1 item 0 numbers
  let n2 item 1 numbers
  let t1 measurement-turtles p1 n1
  let t2 measurement-turtles p2 n2
  let distances []
  ask t1 [
    ask t2 [
      set distances lput distance myself distances
      if n1 > 1 [
        ask myself [ shuffle-in-patch ]
      ]
      if n2 > 1 and n1 > 1 [
        shuffle-in-patch
      ]
    ]
  ]
  ask t1 [die]
  ask t2 [die]
  report mean distances
end

to-report measurement-turtles [p n]
  let ts turtle-set nobody
  ask p [
    sprout n [ 
      if n > 1 [ shuffle-in-patch ]
      set ts (turtle-set ts self)
    ]
  ]
  report ts
end

to shuffle-in-patch 
  setxy pxcor + (random-float 1) - 0.5 pycor + (random-float 1) - 0.5
end

to-report get-required-numbers [s]
  let src item 0 s
  let dest item 1 s
  ifelse src = "c" [
    ifelse dest = "c"
    [ report [1 1] ]
    [ report [1 2500] ]
  ]
  [
    ifelse dest = "c" 
    [ report [2500 1] ]
    [ report [50 50] ]
  ]
end

;to setup-python
;  py:setup py:python3
;  py:run "import random"
;  py:set "kernel" kernel-offsets
;  py:set "weights" kernel-weights
;  py:run "from collections import Counter"
;end
;
;to-report py-multinomial [n]
;;  py:set "kernel" kern
;;  py:set "w" wghts
;  py:set "n" n
;  (py:run
;    "offsets = random.choices(kernel, weights = weights, k = n)"
;    "offsets = [tuple(L) for L in offsets]"
;    "hist = Counter(offsets)"
;  )
;  report py:runresult "[z for z in zip([list(k) for k in hist.keys()], [v for v in hist.values()])]"
;end

;; The MIT License (MIT)
;;
;; Copyright (c) 2020 David O'Sullivan
;;
;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without restriction,
;; including without limitation the rights to use, copy, modify, merge,
;; publish, distribute, sublicense, and/or sell copies of the Software,
;; and to  permit persons to whom the Software is furnished to do so,
;; subject to the following conditions:
;;
;; The above copyright notice and this permission notice shall be included
;; in all copies or substantial portions of the Software.
;;
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

to disperse
  (foreach get-next-generation (n-values num-pops [i -> i]) [
    [new-cases idx] ->
    ifelse new-cases > 0 [
      let n-ldds binomial new-cases p-ldd
      repeat n-ldds [
        disperse-to one-of roads 1 idx
      ]
      ifelse use-kernel-method? [
        if new-cases > n-ldds [
          (foreach kernel-offsets multinomial (new-cases - n-ldds) conditional-kernel-weights false [            [xy num] ->
            let octants [
              [-1 -1 true] [-1 1 true] [1 -1 true] [1 1 true]
              [-1 -1 false] [-1 1 false] [1 -1 false] [1 1 false]
            ]
            let equal-conditional-probs reverse map [ x -> 1 / x ] n-values 8 [i -> i + 1]
            (foreach octants multinomial num equal-conditional-probs false [
              [q n] ->
              ifelse item 2 q
              [ disperse-to patch-at (item 0 xy * item 0 q) (item 1 xy * item 1 q) n idx]
              [ disperse-to patch-at (item 1 xy * item 0 q) (item 0 xy * item 1 q) n idx]
            ]) 
          ])
        ]
      ]
      [
        repeat (new-cases - n-ldds) [
          let target nobody
          while [target = nobody] [
            set target patch-at-heading-and-distance (random-float 360) (random-exponential d-mean)
          ]
          ask target [
            if capacity > 0 [ ; and sum next-pops < capacity [
              set next-pops replace-item idx next-pops (item idx next-pops + 1)
              ;          let i floor distance myself
              ;          array:set distances i (array:item distances i) + 1
            ]
          ]
        ]
      ]
    ]
    [
      set next-pops replace-item idx next-pops 0
    ]
  ])
end


to disperse-to [tgt num idx-type]
  if tgt != nobody [
    ask tgt [
      if capacity > 0 [
        set next-pops replace-item idx-type next-pops (item idx-type next-pops + num)
      ]
    ]
  ]
end


to-report get-dispersal-counts [n]
  let bins map [ p -> length filter [ f -> f < p ] cumulative-kernel-weights ] n-values n [random-float 1]
  report map [ i -> length filter [ b -> b = i ] bins] n-values length cumulative-kernel-weights [i -> i]
end

to-report kernel-cum-frequencies [k]
end

;; The MIT License (MIT)
;;
;; Copyright (c) 2020 David O'Sullivan
;;
;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without restriction,
;; including without limitation the rights to use, copy, modify, merge,
;; publish, distribute, sublicense, and/or sell copies of the Software,
;; and to  permit persons to whom the Software is furnished to do so,
;; subject to the following conditions:
;;
;; The above copyright notice and this permission notice shall be included
;; in all copies or substantial portions of the Software.
;;
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

to disperse
  (foreach (get-next-generation) (n-values num-pops [i -> i]) [
    [new-cases idx] ->
    ifelse new-cases > 0 [
      let n-ldds binomial new-cases p-ldd
      repeat n-ldds [
        disperse-to one-of roads 1 idx
      ]
      ifelse use-kernel-method? [
        if new-cases > n-ldds [
          let targets rnd:weighted-n-of-list-with-repeats (new-cases - n-ldds) my-kernel [p -> last p]
;          let targets rnd:weighted-n-of-list-with-repeats (new-cases - n-ldds) kernel [p -> ifelse-value (my-patch-at first p = nobody) [0] [last p]]
          foreach targets [
            t ->
            let xy item 0 t
            let x item 0 xy
            let y item 1 xy
            disperse-to patch-at x y 1 idx
          ]
        ]
      ]
      [
        repeat (new-cases - n-ldds) [
          let target nobody
          while [target = nobody] [
            set target patch-at-heading-and-distance (random-float 360) (random-exponential d-mean)
          ]
          ask target [
            if capacity > 0 [
              set next-pops replace-item idx next-pops (item idx next-pops + 1)
            ]
          ]
        ]
      ]
    ]
    [
      set next-pops replace-item idx next-pops 0
    ]
  ])
end


to-report my-patch-at [xy]
  report patch-at item 0 xy item 1 xy
end


to disperse-to [tgt num idx-type]
  if tgt != nobody [
    ask tgt [
      if capacity > 0 [
        set next-pops replace-item idx-type next-pops (item idx-type next-pops + num)
      ]
    ]
  ]
end


to-report get-dispersal-counts [n]
  let targets rnd:weighted-n-of-list-with-repeats n kernel [p -> last p]
  set targets map [ xy -> first xy ] targets
  let unique-targets remove-duplicates targets
  report map [tgt -> (list tgt (length filter [xy -> xy = tgt] targets)) ] unique-targets 
end


to setup-kernels
  let r ceiling d-mean * 5
  let dxs n-values (2 * r + 1) [x -> x - r]
  let dys n-values (2 * r + 1) [y -> y - r]
  
  set kernel-offsets []
  set kernel-weights []
  
  foreach dxs [ x ->
    foreach dys [ y ->
      set kernel-offsets lput (list x y) kernel-offsets 
    ]
  ]
  set kernel-offsets filter [ xy -> dist xy <= r ] kernel-offsets
  set kernel-offsets sort-by [ [xy1 xy2] -> dist xy1 < dist xy2 ] kernel-offsets
  set kernel-weights map [ xy -> 1 / d-mean / exp (dist xy / d-mean) ] kernel-offsets
  let total-w sum kernel-weights
  set kernel-weights filter [ w -> w / total-w > p-ldd ] kernel-weights
  let kernel-size length kernel-weights
  set kernel-offsets sublist kernel-offsets 0 kernel-size
;  set conditional-kernel-weights get-conditional-binom-probs kernel-weights
;  set cumulative-kernel-weights cum-frequencies kernel-weights
  set kernel (map [ [o p] -> (list o p) ] kernel-offsets kernel-weights) 
  ask patches [
    set my-kernel filter [ xyp -> my-patch-at item 0 xyp != nobody and [capacity] of my-patch-at item 0 xyp > 0 ] kernel
  ]
end

to-report dist [xy]
  report sqrt (item 0 xy ^ 2 + item 1 xy ^ 2)
end


to-report cum-frequencies [k]
  let total-freqs sum k
  let freqs map [ f -> f / total-freqs ] k
  report reduce [ [a b] -> lput (last a + b) a ] (fput (list first freqs) but-first freqs)  
end
